<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Luxury Todo - Premium Task Management</title>

  <!-- Meta tags -->
  <meta name="description" content="Ultra-premium todo app with glass-morphism design and premium audio">
  <meta name="theme-color" content="#1a1a2e">

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236366f1'%3E%3Cpath d='M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z'/%3E%3C/svg%3E">

  <!-- Styles -->
  <link rel="stylesheet" href="styles/design-system.css">
  <link rel="stylesheet" href="styles/luxury-base.css">
  <link rel="stylesheet" href="styles/luxury-components.css">
  <link rel="stylesheet" href="styles/modal-styles.css">
  <link rel="stylesheet" href="styles/luxury-responsive.css">
  <link rel="stylesheet" href="styles/animations.css">
  <link rel="stylesheet" href="styles/zen-achievements.css">

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600;700&family=SF+Pro+Display:wght@300;400;500;600;700&display=swap"
    rel="stylesheet">

  <!-- Theme loading styles moved to styles/luxury-base.css -->
</head>

<body class="font-inter theme-emerald loading-theme">
  <!-- Background -->
  <div class="background-container">
    <div class="nebula-bg"></div>
    <div class="grain-overlay"></div>
  </div>

  <!-- Main App -->
  <div class="app-container">
    <!-- Header -->
    <header class="app-header">
      <div class="header-content">
        <h1 class="app-title">Luxury Todo</h1>
        <p class="daily-quote" title="Click to change quote">Loading daily quote...</p>
      </div>
    </header>

    <!-- Add Task Section -->
    <section class="add-task-section">
      <form id="addTaskForm" class="add-task-form">
        <div class="input-container">
          <input type="text" id="newTaskInput" class="task-input" placeholder="Add a new task..." maxlength="500"
            autocomplete="off">
          <button type="submit" class="btn btn--primary btn--large" aria-label="Add task">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <line x1="12" y1="5" x2="12" y2="19"></line>
              <line x1="5" y1="12" x2="19" y2="12"></line>
            </svg>
          </button>
        </div>
        <textarea id="newTaskDescription" class="task-description-input" placeholder="Add description (optional)..."
          maxlength="500" rows="3"></textarea>
        <div class="char-counter" style="text-align: right; font-size: 0.75rem; opacity: 0.6;">
          <span id="descCounter">0/500</span>
        </div>
      </form>
    </section>

    <!-- Filters -->
    <nav class="filter-group">
      <button class="btn btn--ghost active" data-filter="all">All</button>
      <button class="btn btn--ghost" data-filter="active">Active</button>
      <button class="btn btn--ghost" data-filter="completed">Completed</button>
    </nav>

    <!-- Task List -->
    <main class="task-list-container">
      <div id="taskList" class="task-list"></div>

      <!-- Empty State -->
      <div id="emptyState" class="empty-state">
        <div class="empty-icon">
          <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1">
            <path d="M9 11H5a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2z"></path>
            <path d="M19 11h-4a2 2 0 0 0-2 2v7a2 2 0 0 0 2 2h4a2 2 0 0 0 2-2v-7a2 2 0 0 0-2-2z"></path>
            <path d="M5 11V7a7 7 0 0 1 14 0v4"></path>
            <path d="M12 5V2"></path>
          </svg>
        </div>
        <h3>No tasks yet</h3>
        <p>Add your first task to get started</p>
      </div>
    </main>

    <!-- Task Count -->
    <footer class="task-footer">
      <span id="taskCount">0 tasks remaining</span>
      <div class="footer-actions">
        <button id="testDataBtn" class="btn btn--subtle" data-action="test-data" title="Add test tasks">Test</button>
        <button id="clearCompleted" class="btn" data-action="clear-completed">Clear Completed</button>
        <button id="deleteAllBtn" class="btn" data-action="delete-all">Delete All</button>
      </div>
    </footer>
  </div>


  <!-- Settings Panel (static structure, sections enhanced dynamically by JS) -->
  <div id="settingsPanel" class="settings-panel">
    <div class="settings-header">
      <h3>Settings</h3>
      <button class="close-btn" onclick="settingsManager.closeSettings()">×</button>
    </div>

    <div class="settings-content">
      <!-- Font Section -->
      <div class="settings-section" id="fontSection">
        <h4>Font</h4>
        <div class="font-selector" id="fontSelector">
          <!-- Dynamically enhanced by js/settings.js -->
          <button class="font-option" data-font="inter">Inter</button>
          <button class="font-option" data-font="playfair">Playfair</button>
          <button class="font-option" data-font="sf">SF Pro</button>
        </div>
      </div>

      <!-- Sound Section -->
      <div class="settings-section" id="soundSection">
        <h4>Sound</h4>
        <div class="volume-control">
          <label class="settings-checkbox">
            <input type="checkbox" id="soundToggle" />
            <span class="checkmark" aria-hidden="true"></span>
          </label>
          <div class="volume-slider-container">
            <div class="volume-fill" id="volumeFill" style="width: 50%"></div>
            <div class="volume-slider" id="volumeSlider" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="50"></div>
            <div class="volume-handle" id="volumeHandle" style="left: 50%"></div>
          </div>
        </div>
      </div>

      <!-- Utilities Section (Reset to Defaults injected/enhanced by JS) -->
      <div class="settings-section" id="utilitiesSection">
        <h4>Utilities</h4>
        <div id="utilitiesContainer">
          <!-- Reset to Defaults button will be injected here by js/settings.js with custom modal -->
        </div>
      </div>

      <!-- Theme Section (at bottom) -->
      <div class="settings-section" id="themeSection">
        <h4>Theme</h4>
        <div class="theme-selector">
          <div class="theme-cards-container" id="themeCardsContainer">
            <!-- Theme cards dynamically rendered by js/settings.js -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Floating Controls -->
  <div class="floating-controls">
    <button id="statisticsBtn" class="btn btn--floating" title="Statistics">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <line x1="18" y1="20" x2="18" y2="10"></line>
        <line x1="12" y1="20" x2="12" y2="4"></line>
        <line x1="6" y1="20" x2="6" y2="14"></line>
      </svg>
    </button>

    <!-- Music Control Button (placed to the left of Settings on desktop) -->
    <button id="musicBtn" class="btn btn--floating btn--floating-audio" title="Music">
      <svg id="musicIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
        stroke-width="2">
        <path d="M9 18V5l12-2v13"></path>
        <circle cx="6" cy="18" r="3"></circle>
        <circle cx="18" cy="16" r="3"></circle>
      </svg>
    </button>

    <button id="volumeBtn" class="btn btn--floating btn--floating-audio" title="Toggle Sound">
      <svg id="volumeIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor"
        stroke-width="2">
        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
        <path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>
      </svg>
    </button>

    <!-- Music Popover -->
    <div id="musicPopover" class="music-popover" style="display:none;">
      <div class="music-popover-header">
        <!-- Frequency-driven visualizer container (will be populated by js/music-visualizer.js) -->
        <div class="music-visualizer" id="musicFrequencyBars" aria-hidden="false">
          <!-- Small sticky button placed top-right over the visualizer -->
          <button id="musicPinBtn" class="btn btn--icon btn--ghost music-pin small" title="Pin panel" aria-pressed="false">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M16 3l5 5-7 7-4 1 1-4 7-7z"></path>
              <path d="M15 4l5 5"></path>
              <path d="M2 22l6-6"></path>
            </svg>
          </button>
        </div>
      </div>
      <!-- Progress inside visualizer -->
      <div class="music-progress" aria-label="Track progress" title="Seek">
        <div class="music-progress-track" id="musicProgressTrack">
          <div class="music-progress-fill" id="musicProgressFill" style="width:0%"></div>
          <div class="music-progress-handle" id="musicProgressHandle" style="left:0%"></div>
        </div>
        <div class="music-timecodes">
          <span id="musicCurrentTime">0:00</span>
          <span id="musicDuration">0:00</span>
        </div>
      </div>

      <div class="music-transport">
        <button id="musicPrev" class="btn btn--icon" title="Previous">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M19 20L9 12l10-8v16z"></path>
            <line x1="5" y1="19" x2="5" y2="5"></line>
          </svg>
        </button>
        <button id="musicPlayPause" class="btn btn--icon" title="Play/Pause">
          <svg id="musicPlayIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2">
            <polygon points="5 3 19 12 5 21 5 3"></polygon>
          </svg>
          <svg id="musicPauseIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
            stroke-width="2" style="display:none;">
            <rect x="6" y="4" width="4" height="16"></rect>
            <rect x="14" y="4" width="4" height="16"></rect>
          </svg>
        </button>
        <button id="musicNext" class="btn btn--icon" title="Next">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M5 4l10 8-10 8V4z"></path>
            <line x1="19" y1="5" x2="19" y2="19"></line>
          </svg>
        </button>
      </div>
      <div class="music-volume">
        <span class="music-label">Music</span>
        <div class="music-slider-container">
          <div class="music-fill" id="musicFill" style="width: 45%"></div>
          <div class="music-slider" id="musicSlider" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="45"></div>
          <div class="music-handle" id="musicHandle" style="left: 45%"></div>
        </div>
      </div>
    </div>

    <button id="settingsBtn" class="btn btn--floating" onclick="settingsManager.toggleSettings()" title="Settings">
      <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="3"></circle>
        <path
          d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l-.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1 1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
        </path>
      </svg>
    </button>
  </div>

  <!-- Statistics Panel -->
  <div id="statisticsPanel" class="statistics-panel">
    <div class="statistics-header">
      <h3>Statistics</h3>
      <button class="close-btn" onclick="statisticsManager.closeStatistics()">×</button>
    </div>

    <div class="statistics-content">
      <div class="stats-progress-ring">
        <svg class="stats-progress-svg" viewBox="0 0 140 140">
          <circle class="stats-progress-bg" cx="70" cy="70" r="60"></circle>
          <circle id="statsProgressRing" class="stats-progress-fill" cx="70" cy="70" r="60"></circle>
        </svg>
        <div class="stats-percentage">
          <span id="statsPercentage">0%</span>
        </div>
      </div>

      <div class="stats-info">
        <div class="stat-item">
          <span class="stat-value" id="statsTotal">0</span>
          <span class="stat-label">Total</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="statsCompleted">0</span>
          <span class="stat-label">Done</span>
        </div>
        <div class="stat-item">
          <span class="stat-value" id="statsKarma">0</span>
          <span class="stat-label">Karma</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Modal Overlay -->
  <div id="modalOverlay" class="modal-overlay" aria-hidden="true"></div>

  <!-- Modal Container -->
  <div id="modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle"
    aria-describedby="modalDescription">
    <div class="modal-content">
      <div class="modal-header">
        <h3 id="modalTitle" class="modal-title">Confirm Action</h3>
        <button class="close-btn modal-close" aria-label="Close modal">×</button>
      </div>
      <div class="modal-body">
        <p id="modalDescription">Are you sure you want to perform this action?</p>
      </div>
      <div class="modal-footer">
        <button id="modalCancelButton" class="btn btn--ghost">Cancel</button>
        <button id="modalConfirmButton" class="btn btn--primary">Confirm</button>
      </div>
    </div>
  </div>

  <!-- App Footer -->
  <div class="app-footer">
    <p class="footer-text">
      Vibe Coded by Raúl Correia
      <span class="heart-emoji">❤️</span>
      with <span class="llm-name">Kimi K2 and GLM-4.5 Air</span>
      <span class="app-version" id="appVersion"></span>
    </p>
  </div>

  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <script>
    // Initialize Lucide when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      if (typeof lucide !== 'undefined') {
        lucide.createIcons();
      }
    });
  </script>

  <!-- Version Script -->
  <script src="js/version.js"></script>

  <!-- Environment Configuration -->
  <script src="js/environment.js"></script>

  <!-- Scripts -->
  <script src="js/bus.js"></script>
  <script src="js/storage.js"></script>
  <script src="js/themes.js"></script>
  <script src="js/audio.js"></script>
  <script src="js/music.js"></script>
  <script src="js/music-visualizer.js"></script>
  <script src="js/animations.js"></script>
  <script src="js/achievement-definitions.js"></script>
  <script src="js/gamification.js"></script>
  <script src="js/statistics.js"></script>

  <!-- Ensure modal-manager is available before settings.js so the custom confirm is ready -->
  <script src="js/modal-manager.js"></script>

  <script src="js/settings.js"></script>
  <script src="js/settings-loader.js"></script>
  <script src="js/quotes.js"></script>
  <script src="js/affirmations.js"></script>
  <script src="js/daily-summary.js"></script>
  <script src="js/swipe-gestures.js"></script>
  <script src="js/nebula-parallax.js"></script>
  <script src="js/ai-providers.js"></script>
  <script src="js/app.js"></script>
<script>
// Music UI wiring (pointer-only)
(function() {
  const btn = document.getElementById('musicBtn');
  const icon = document.getElementById('musicIcon');
  const pop = document.getElementById('musicPopover');
  const prev = document.getElementById('musicPrev');
  const playPause = document.getElementById('musicPlayPause');
  const playI = document.getElementById('musicPlayIcon');
  const pauseI = document.getElementById('musicPauseIcon');
  const next = document.getElementById('musicNext');
  const slider = document.getElementById('musicSlider');
  const fill = document.getElementById('musicFill');
  const handle = document.getElementById('musicHandle');
  const pinBtn = document.getElementById('musicPinBtn');
  const visualizer = document.querySelector('#musicPopover .music-visualizer');

  if (!btn || !pop) return;

  // Position popover directly above the music button with spacing, accounting for transforms
  function positionPopover() {
    const btnRect = btn.getBoundingClientRect();
    const btnStyles = window.getComputedStyle(btn);
    const btnTransform = btnStyles.transform;

    // Measure popover at full size by making it temporarily visible off-screen
    const prevDisplay = pop.style.display;
    const prevVisibility = pop.style.visibility;
    const prevLeft = pop.style.left;
    const prevTop = pop.style.top;

    pop.style.visibility = 'hidden';
    pop.style.display = 'block';
    pop.style.left = '-9999px';
    pop.style.top = '-9999px';

    const popWidth = pop.offsetWidth || 260;
    const popHeight = pop.offsetHeight || 140;

    // Restore before positioning
    pop.style.visibility = prevVisibility || '';
    pop.style.display = prevDisplay || 'none';
    pop.style.left = prevLeft || '';
    pop.style.top = prevTop || '';

    pop.style.position = 'fixed';

    // Horizontal center relative to button center
    const centerX = btnRect.left + btnRect.width / 2;
    let left = Math.round(centerX - popWidth / 2);

    // Clamp within viewport horizontally (8px padding)
    left = Math.max(8, Math.min(left, window.innerWidth - popWidth - 8));
    pop.style.left = `${left}px`;
    pop.style.right = 'auto';

    // Vertical: strictly above with spacing
    const SPACING = 12;
    // If button has transforms (e.g., scale), btnRect already accounts; just position above
    let top = Math.round(btnRect.top - popHeight - SPACING);

    // Clamp to top padding if not enough room; still keep it "above" visually
    top = Math.max(8, top);

    pop.style.top = `${top}px`;
    pop.style.bottom = 'auto';
    pop.classList.add('above');
    pop.classList.remove('below');
  }

  function showPopover() {
    positionPopover();
    pop.style.display = 'block';
    pop.classList.add('open');
    // Notify visualizer that it is now visible
    if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
      bus.dispatchEvent(new CustomEvent('musicVisualizerShown', {}));
    }
  }
  function hidePopover() {
    if (pop.classList.contains('sticky')) return; // keep open when sticky
    pop.classList.remove('open');
    pop.style.display = 'none';
    // Notify visualizer that it is now hidden
    if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
      bus.dispatchEvent(new CustomEvent('musicVisualizerHidden', {}));
    }
  }

  // Music button clicked: emit event for downstream listeners (no direct toggleMute)
  btn.addEventListener('click', async () => {
    if (typeof musicManager === 'undefined') return;
    musicManager.init();

    // Fire semantic event so other modules (e.g., visualizer) can react
    if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
      bus.dispatchEvent(new CustomEvent('musicButtonClicked', {}));
    }
  });

  // Hover/focus show popover (desktop)
  btn.addEventListener('mouseenter', showPopover);
  btn.addEventListener('mouseleave', () => {
    // Close when pointer leaves both btn and pop (unless sticky)
    setTimeout(() => {
      const over = pop.matches(':hover') || btn.matches(':hover');
      if (!over) hidePopover();
    }, 100);
  });
  pop.addEventListener('mouseleave', () => {
    setTimeout(() => {
      const over = pop.matches(':hover') || btn.matches(':hover');
      if (!over) hidePopover();
    }, 50);
  });
  // Mobile tap toggles popover
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (pop.style.display === 'block') hidePopover();
    else showPopover();
  }, { passive: false });

  // Sticky pin behavior
  if (pinBtn) {
    pinBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      const willStick = !pop.classList.contains('sticky');
      pop.classList.toggle('sticky', willStick);
      pinBtn.setAttribute('aria-pressed', String(willStick));
      pinBtn.classList.toggle('pinned', willStick);
      if (willStick) {
        showPopover();
      }
      // Inform visualizer/other listeners of sticky state changes
      if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
        bus.dispatchEvent(new CustomEvent('musicVisualizerStickyChanged', { detail: { sticky: willStick }}));
      }
    });
  }

  // New: Visualizer display should react to musicButtonClicked (show + init visualizer)
  if (typeof bus !== 'undefined') {
    bus.addEventListener('musicButtonClicked', () => {
      // Toggle sticky state on click of the music button
      const willStick = !pop.classList.contains('sticky');
      pop.classList.toggle('sticky', willStick);
      if (pinBtn) {
        pinBtn.setAttribute('aria-pressed', String(willStick));
        pinBtn.classList.toggle('pinned', willStick);
      }
      if (willStick) {
        showPopover();
      } else {
        hidePopover();
      }
      // Broadcast sticky state to any visualizer listeners
      if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
        bus.dispatchEvent(new CustomEvent('musicVisualizerStickyChanged', { detail: { sticky: willStick }}));
      }
      // Explicitly ask the visualizer module to initialize and start (idempotent in module)
      if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
        bus.dispatchEvent(new CustomEvent('musicVisualizerEnsureInit', {}));
        bus.dispatchEvent(new CustomEvent('musicVisualizerStart', {}));
      }
    });

    // Also listen for popover visibility to control visualizer loop efficiently
    bus.addEventListener('musicVisualizerShown', () => {
      if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
        bus.dispatchEvent(new CustomEvent('musicVisualizerEnsureInit', {}));
        bus.dispatchEvent(new CustomEvent('musicVisualizerStart', {}));
      }
    });
    bus.addEventListener('musicVisualizerHidden', () => {
      if (typeof bus !== 'undefined' && typeof bus.dispatchEvent === 'function') {
        bus.dispatchEvent(new CustomEvent('musicVisualizerStop', {}));
      }
    });
  }

  // Progress (seek) wiring
  (function setupProgress() {
    const track = document.getElementById('musicProgressTrack');
    const fill = document.getElementById('musicProgressFill');
    const handle = document.getElementById('musicProgressHandle');
    const curT = document.getElementById('musicCurrentTime');
    const durT = document.getElementById('musicDuration');
    if (!track || !fill || !handle) return;

    let dragging = false;
    let lastPct = 0;

    const fmt = (sec) => {
      if (!isFinite(sec)) return '0:00';
      const m = Math.floor(sec / 60);
      const s = Math.floor(sec % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    };

    const setUI = (pct) => {
      lastPct = Math.max(0, Math.min(100, pct));
      fill.style.width = `${lastPct}%`;
      handle.style.left = `${lastPct}%`;
      // timecodes
      if (window.musicManager) {
        const el = musicManager.audioEls[musicManager.currentIndex];
        if (el && isFinite(el.duration) && el.duration > 0) {
          const cur = (el.duration * lastPct) / 100;
          curT.textContent = fmt(cur);
          durT.textContent = fmt(el.duration);
        }
      }
    };

    const pctFromClientX = (clientX) => {
      const rect = track.getBoundingClientRect();
      const x = Math.max(rect.left, Math.min(clientX, rect.right));
      return ((x - rect.left) / rect.width) * 100;
    };

    const onDown = (clientX) => {
      dragging = true;
      setUI(pctFromClientX(clientX));
      track.classList.add('active');
      handle.classList.add('active');
    };
    const onMove = (clientX) => {
      if (!dragging) return;
      setUI(pctFromClientX(clientX));
    };
    const onUp = () => {
      if (!dragging) return;
      dragging = false;
      track.classList.remove('active');
      handle.classList.remove('active');
      // Apply seek
      if (window.musicManager) {
        const el = musicManager.audioEls[musicManager.currentIndex];
        if (el && isFinite(el.duration) && el.duration > 0) {
          const t = (el.duration * lastPct) / 100;
          el.currentTime = t;
          // If not playing, do not auto-play; keep policy. If playing, music continues.
        }
      }
    };

    // Mouse
    track.addEventListener('mousedown', (e) => onDown(e.clientX));
    document.addEventListener('mousemove', (e) => onMove(e.clientX));
    document.addEventListener('mouseup', onUp);

    // Touch
    track.addEventListener('touchstart', (e) => { if (!e.touches || !e.touches[0]) return; e.preventDefault(); onDown(e.touches[0].clientX); }, { passive: false });
    document.addEventListener('touchmove', (e) => { if (!e.touches || !e.touches[0]) return; e.preventDefault(); onMove(e.touches[0].clientX); }, { passive: false });
    document.addEventListener('touchend', onUp);

    // Sync from audio timeupdate
    const syncFromAudio = () => {
      if (dragging) return;
      if (!window.musicManager) return;
      const el = musicManager.audioEls[musicManager.currentIndex];
      if (!el || !isFinite(el.duration) || el.duration <= 0) {
        setUI(0);
        curT.textContent = '0:00';
        durT.textContent = '0:00';
        return;
      }
      const pct = (el.currentTime / el.duration) * 100;
      setUI(pct);
    };

    // Attach to current element and on track switches
    const attachTimeUpdate = () => {
      if (!window.musicManager) return;
      const el = musicManager.audioEls[musicManager.currentIndex];
      if (!el) return;
      el.addEventListener('timeupdate', syncFromAudio);
      el.addEventListener('durationchange', syncFromAudio);
      el.addEventListener('loadedmetadata', syncFromAudio);
      // initial sync
      syncFromAudio();
    };
    attachTimeUpdate();

    if (typeof bus !== 'undefined') {
      // Reattach on next/prev play
      bus.addEventListener('music:playing', () => {
        attachTimeUpdate();
        syncFromAudio();
      });
      bus.addEventListener('music:paused', () => syncFromAudio());
      bus.addEventListener('music:silenceStart', () => setUI(0)); // starting next after silence resets UI; next() will resync
    }
  })();

  // Transport
  if (prev) prev.addEventListener('click', () => musicManager && musicManager.prev());
  if (next) next.addEventListener('click', () => musicManager && musicManager.next());
  if (playPause) playPause.addEventListener('click', async () => {
    if (!musicManager) return;
    await musicManager.togglePlay();
    const playing = musicManager.isPlaying;
    playI.style.display = playing ? 'none' : 'inline';
    pauseI.style.display = playing ? 'inline' : 'none';
  });

  // Volume button toggles global sound enabled/disabled and mirrors music mute state
  (function setupVolumeButtonToggle() {
    const vBtn = document.getElementById('volumeBtn');
    const vIcon = document.getElementById('volumeIcon');

    if (!vBtn) return;

    // Store last known music transport state so we can restore on unmute (persisted)
    let lastMusicWasPlaying = false;
    const SOUND_ENABLED_KEY = 'sound.enabled';
    const SOUND_LAST_TRANSPORT_KEY = 'sound.lastTransport';

    // Helper to reflect enabled/disabled UI state (cross overlay)
    const reflectSoundState = (enabled) => {
      if (enabled) {
        vBtn.classList.add('enabled');
        vBtn.classList.remove('disabled');
      } else {
        vBtn.classList.add('disabled');
        vBtn.classList.remove('enabled');
      }
      if (typeof settingsManager !== 'undefined' && vIcon) {
        try {
          settingsManager.updateVolumeIcon(vIcon, enabled);
        } catch(e) {
          // no-op
        }
      }
    };

    // Initial sync once managers are available
    const initialSync = async () => {
      // Determine enabled from storage or settings (default true)
      let enabled = true;
      try {
        const stored = localStorage.getItem(SOUND_ENABLED_KEY);
        if (stored === 'true' || stored === 'false') {
          enabled = (stored === 'true');
        } else if (typeof settingsManager !== 'undefined' && typeof settingsManager.soundEnabled !== 'undefined') {
          enabled = !!settingsManager.soundEnabled;
          localStorage.setItem(SOUND_ENABLED_KEY, String(enabled));
        } else {
          localStorage.setItem(SOUND_ENABLED_KEY, 'true');
        }
      } catch(e) { /* no-op */ }

      // Last transport default paused if unknown
      try {
        const lt = localStorage.getItem(SOUND_LAST_TRANSPORT_KEY);
        lastMusicWasPlaying = (lt === 'playing');
      } catch(e) { lastMusicWasPlaying = false; }

      reflectSoundState(enabled);

      if (typeof musicManager !== 'undefined') {
        // If disabled at load: ensure paused and muted
        if (!enabled) {
          if (musicManager.isPlaying) {
            try { await musicManager.pause(); } catch(e) {}
          }
          if (!musicManager.isMuted) {
            try { await musicManager.toggleMute(); } catch(e) {}
          }
        } else {
          // Enabled at load: do not auto-play; ensure UI matches current mute
          // Do not force unmute if user had muted manually in a prior session.
        }
      }
    };

    // Click toggles settings + music mute and manages transport restore behavior (stop on mute, restore on unmute)
    vBtn.addEventListener('click', async () => {
      // Current enabled from storage/settings (default true)
      let enabledNow = true;
      try {
        const stored = localStorage.getItem(SOUND_ENABLED_KEY);
        if (stored === 'true' || stored === 'false') {
          enabledNow = (stored === 'true');
        } else if (typeof settingsManager !== 'undefined' && typeof settingsManager.soundEnabled !== 'undefined') {
          enabledNow = !!settingsManager.soundEnabled;
        }
      } catch(e) { /* no-op */ }

      const nextEnabled = !enabledNow;

      // Persist sound.enabled
      try { localStorage.setItem(SOUND_ENABLED_KEY, String(nextEnabled)); } catch(e) {}

      // Persist via settings if available
      if (typeof settingsManager !== 'undefined' && typeof settingsManager.setSoundEnabled === 'function') {
        try { settingsManager.setSoundEnabled(nextEnabled); } catch(e) { /* no-op */ }
      }

      if (typeof musicManager !== 'undefined') {
        if (!nextEnabled) {
          // Turning OFF: store last transport, stop playback, then mute
          lastMusicWasPlaying = !!musicManager.isPlaying;
          try { localStorage.setItem(SOUND_LAST_TRANSPORT_KEY, lastMusicWasPlaying ? 'playing' : 'paused'); } catch(e) {}

          if (musicManager.isPlaying) {
            try { await musicManager.pause(); } catch(e) {}
          }
          if (!musicManager.isMuted) {
            try { await musicManager.toggleMute(); } catch(e) {}
          }
        } else {
          // Turning ON: unmute first, then restore last transport
          if (musicManager.isMuted) {
            try { await musicManager.toggleMute(); } catch(e) {}
          }
          // Restore last known transport preference
          let lt = 'paused';
          try {
            const storedLt = localStorage.getItem(SOUND_LAST_TRANSPORT_KEY);
            if (storedLt === 'playing' || storedLt === 'paused') lt = storedLt;
          } catch(e) {}
          if (lt === 'playing') {
            try { await musicManager.play(); } catch(e) {}
            lastMusicWasPlaying = true;
          } else {
            // remain paused
            lastMusicWasPlaying = false;
          }
        }
      }

      reflectSoundState(nextEnabled);
    });

    // Listen to settings changes for cross-tab/other UI sync
    if (typeof bus !== 'undefined') {
      bus.addEventListener('settingsChanged', () => {
        const enabled = (typeof settingsManager !== 'undefined' && typeof settingsManager.soundEnabled !== 'undefined')
          ? !!settingsManager.soundEnabled
          : true;
        reflectSoundState(enabled);
      });
      // Keep overlay in sync even if mute changed elsewhere
      bus.addEventListener('music:muted', (ev) => {
        const muted = !!(ev && ev.detail && ev.detail.muted);
        reflectSoundState(!muted);
      });
      // Track transport state to restore on unmute correctly (and persist)
      bus.addEventListener('music:playing', () => { 
        lastMusicWasPlaying = true; 
        try { localStorage.setItem(SOUND_LAST_TRANSPORT_KEY, 'playing'); } catch(e) {}
      });
      bus.addEventListener('music:paused', () => { 
        lastMusicWasPlaying = false; 
        try { localStorage.setItem(SOUND_LAST_TRANSPORT_KEY, 'paused'); } catch(e) {}
      });
      bus.addEventListener('music:silenceStart', () => { 
        lastMusicWasPlaying = false; 
        try { localStorage.setItem(SOUND_LAST_TRANSPORT_KEY, 'paused'); } catch(e) {}
      });
    }

    // Do one initial sync after a brief delay to allow managers to initialize
    setTimeout(initialSync, 0);
  })();

  // Volume slider (pointer-only, with apply on release)
  // No separate enable/disable toggle; volume button now controls sound enable/disable

  if (slider && handle) {
    let isDragging = false;
    let temp = (typeof musicManager !== 'undefined') ? (musicManager.targetVolume * 100) : 45;

    const updateUI = (pct) => {
      fill.style.width = `${pct}%`;
      handle.style.left = `${pct}%`;
      slider.setAttribute('aria-valuenow', String(Math.round(pct)));
    };
    updateUI(temp);

    const pctFromEvent = (e) => {
      const rect = slider.getBoundingClientRect();
      const x = e.clientX || (e.touches && e.touches[0].clientX);
      return Math.max(0, Math.min(100, ((x - rect.left) / rect.width) * 100));
    };

    const onDown = (e) => { isDragging = true; temp = pctFromEvent(e); updateUI(temp); };
    const onMove = (e) => { if (!isDragging) return; temp = pctFromEvent(e); updateUI(temp); };
    const onUp = () => {
      if (!isDragging) return;
      isDragging = false;
      if (typeof musicManager !== 'undefined') {
        musicManager.init();
        musicManager.setVolume(temp / 100, { smooth: true });
        // if user unmuted via slider (>0) and currently muted, do not auto-unmute per spec
      }
    };

    slider.addEventListener('mousedown', onDown);
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);

    slider.addEventListener('touchstart', (e) => { e.preventDefault(); onDown(e.touches[0]); slider.classList.add('active'); handle.classList.add('active'); }, { passive: false });
    document.addEventListener('touchmove', (e) => { if (!isDragging) return; e.preventDefault(); onMove(e.touches[0]); }, { passive: false });
    document.addEventListener('touchend', () => { onUp(); slider.classList.remove('active'); handle.classList.remove('active'); });

    // Sync from manager events
    if (typeof bus !== 'undefined') {
      bus.addEventListener('music:volumeChanged', (ev) => {
        const pct = Math.round((ev.detail.volume || 0) * 100);
        updateUI(pct);
      });
    }
  }

  // Subtle glow hint if autoplay blocked
  if (typeof bus !== 'undefined') {
    bus.addEventListener('music:hintStart', () => {
      btn.classList.add('hint');
      setTimeout(() => btn.classList.remove('hint'), 4000);
    });
    // Spinner on buffering
    bus.addEventListener('music:buffering', (ev) => {
      if (ev.detail && ev.detail.buffering) btn.classList.add('buffering');
      else btn.classList.remove('buffering');
    });
    // Silence indication (optional dim)
    bus.addEventListener('music:silenceStart', () => btn.classList.add('silence'));
    bus.addEventListener('music:silenceEnd', () => btn.classList.remove('silence'));
  }

  // Update play/pause icon based on events
  if (typeof bus !== 'undefined') {
    bus.addEventListener('music:playing', () => {
      playI.style.display = 'none'; pauseI.style.display = 'inline';
      pop.classList.add('is-playing'); btn.classList.add('is-playing');
      if (visualizer) visualizer.classList.add('is-playing');
      pop.classList.remove('is-paused','is-silent');
    });
    bus.addEventListener('music:paused', () => {
      playI.style.display = 'inline'; pauseI.style.display = 'none';
      pop.classList.remove('is-playing'); btn.classList.remove('is-playing');
      if (visualizer) visualizer.classList.remove('is-playing');
      pop.classList.add('is-paused');
    });
    bus.addEventListener('music:muted', (ev) => {
      if (!ev || typeof ev.detail === 'undefined') return;
      const m = !!ev.detail.muted;
      btn.classList.toggle('muted', m);
      pop.classList.toggle('is-muted', m);
      if (visualizer) visualizer.classList.toggle('is-muted', m);
    });
    bus.addEventListener('music:silenceStart', () => {
      pop.classList.add('is-silent'); btn.classList.remove('is-playing');
      if (visualizer) visualizer.classList.remove('is-playing');
    });
    bus.addEventListener('music:silenceEnd', () => {
      pop.classList.remove('is-silent');
    });
    bus.addEventListener('music:buffering', (ev) => {
      const b = !!(ev.detail && ev.detail.buffering);
      pop.classList.toggle('is-buffering', b);
      if (visualizer) visualizer.classList.toggle('is-buffering', b);
    });
    bus.addEventListener('music:volumeChanged', (ev) => {
      const v = Math.max(0, Math.min(1, (ev.detail && ev.detail.volume) || 0));
      document.documentElement.style.setProperty('--music-amp', String(v));
    });
  }

  // Reposition on resize
  window.addEventListener('resize', () => { if (pop.style.display === 'block') positionPopover(); });
  window.addEventListener('scroll', () => { if (pop.style.display === 'block') positionPopover(); }, { passive: true });

  // Close on outside click when not sticky
  document.addEventListener('click', (e) => {
    if (!pop.classList.contains('open') || pop.classList.contains('sticky')) return;
    const within = pop.contains(e.target) || btn.contains(e.target);
    if (!within) hidePopover();
  });
})();
</script>
})();
</script>

<style>
/* Ensure order: statistics, music, volume, settings on wide viewports */
@media (min-width: 900px) {
  .floating-controls {
    display: grid;
    grid-auto-flow: column;
    gap: 12px;
    align-items: end;
  }
  #statisticsBtn { order: 1; }
  #musicBtn { order: 2; }
  #volumeBtn { order: 3; }
  #settingsBtn { order: 4; }
}

/* Shared styles for audio floating buttons (music + volume) */
.btn--floating.btn--floating-audio {
  /* pulse when enabled (not muted) handled by existing JS that adds enabled class on volume; we mirror with is-playing on music */
}
#volumeBtn.btn--floating-audio.enabled,
#musicBtn.btn--floating-audio.is-playing {
  animation: pulseGlow 2s ease-in-out infinite;
}
#volumeBtn.btn--floating-audio.disabled,
#musicBtn.btn--floating-audio.muted {
  animation: none;
}
#volumeBtn.btn--floating-audio.buffering::before,
#musicBtn.btn--floating-audio.buffering::before {
  content: '';
  position: absolute;
  width: 16px; height: 16px;
  border: 2px solid transparent;
  border-top-color: var(--accent-color);
  border-radius: 50%;
  right: 6px; top: 6px;
  animation: spin 1s linear infinite;
}
#volumeBtn.btn--floating-audio.disabled,
#musicBtn.btn--floating-audio.music-disabled { opacity: 0.85; }

/* Music popover header & visualizer */
.music-popover-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.35rem;
  gap: 0.5rem;
}
.music-pin.btn { padding: 2px; opacity: 0.6; }
.music-pin.btn svg { width: 12px; height: 12px; }
.music-pin.btn.pinned { opacity: 1; filter: drop-shadow(0 0 6px var(--glow-color)); }

/* Small sticky button positioned at top-right of the visualizer */
.music-visualizer {
  position: relative; /* enable absolute positioning for pin button */
}
.music-pin.small {
  position: absolute;
  top: 6px;
  right: 6px;
  width: 22px;
  height: 22px;
  padding: 0;
  display: grid;
  place-items: center;
  border-radius: var(--radius-sm, 6px);
  background: rgba(18,18,18,0.35);
  border: 1px solid rgba(255,255,255,0.22);
  backdrop-filter: blur(6px);
  transition: background 120ms ease, opacity 120ms ease, transform 120ms ease;
  opacity: 0.95;
  z-index: 2; /* ensure it sits above bars */
}
.music-pin.small:hover { opacity: 1; background: rgba(18,18,18,0.5); transform: scale(1.04); }
.music-pin.small.pinned {
  box-shadow: 0 0 10px var(--glow-color);
  border-color: var(--accent-color);
}
.music-pin.small svg { width: 12px; height: 12px; }

.music-visualizer {
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: 1fr;
  align-items: end;
  gap: 6px;
  height: clamp(60px, 25vh, 160px);
  width: 100%;
  opacity: 0.0;
  transition: opacity 200ms ease;
}
.music-visualizer.is-playing { opacity: 0.9; }
.music-visualizer.is-muted,
.music-popover.is-muted .music-visualizer,
.music-popover.is-buffering .music-visualizer,
.music-popover.is-paused .music-visualizer,
.music-popover.is-silent .music-visualizer { opacity: 0.35; }
/* keep pin visible even when visualizer is dimmed */
.music-popover.is-muted .music-pin.small,
.music-popover.is-buffering .music-pin.small,
.music-popover.is-paused .music-pin.small,
.music-popover.is-silent .music-pin.small { opacity: 0.95; }

.music-visualizer .bar {
  width: 100%;
  border-radius: 3px;
  background: linear-gradient(180deg, var(--glow-color), var(--accent-color));
  box-shadow: 0 0 8px var(--glow-color);
  height: 18%;
  transform-origin: bottom center;
  animation: vizBreath 1.2s ease-in-out infinite; /* faster baseline for more reactive feel */
  animation-play-state: paused;
}
.music-visualizer.is-playing .bar { animation-play-state: running; }

/* stagger with nth-child to add organic feel (reduced delays for snappier response) */
.music-visualizer .bar:nth-child(1) { animation-delay: 0ms; }
.music-visualizer .bar:nth-child(2) { animation-delay: 60ms; }
.music-visualizer .bar:nth-child(3) { animation-delay: 120ms; }
.music-visualizer .bar:nth-child(4) { animation-delay: 180ms; }
.music-visualizer .bar:nth-child(5) { animation-delay: 240ms; }
.music-visualizer .bar:nth-child(6) { animation-delay: 300ms; }
.music-visualizer .bar:nth-child(7) { animation-delay: 360ms; }
.music-visualizer .bar:nth-child(8) { animation-delay: 420ms; }

@keyframes vizBreath {
  0%   { height: calc(16% + 26% * var(--music-amp, 0.45)); }
  20%  { height: calc(34% + 18% * var(--music-amp, 0.45)); }
  50%  { height: calc(72% + 10% * var(--music-amp, 0.45)); }
  80%  { height: calc(36% + 20% * var(--music-amp, 0.45)); }
  100% { height: calc(16% + 26% * var(--music-amp, 0.45)); }
}

/* Micro equalizer on button */
#musicBtn.is-playing::after {
  content: '';
  position: absolute;
  right: 6px; bottom: 6px;
  width: 12px; height: 6px;
  background:
    linear-gradient(90deg, var(--accent-color), var(--glow-color));
  -webkit-mask:
    radial-gradient(circle 1px at 2px 50%, #000 99%, transparent 100%),
    radial-gradient(circle 1px at 6px 50%, #000 99%, transparent 100%),
    radial-gradient(circle 1px at 10px 50%, #000 99%, transparent 100%);
  mask:
    radial-gradient(circle 1px at 2px 50%, #000 99%, transparent 100%),
    radial-gradient(circle 1px at 6px 50%, #000 99%, transparent 100%),
    radial-gradient(circle 1px at 10px 50%, #000 99%, transparent 100%);
  filter: drop-shadow(0 0 6px var(--glow-color));
  opacity: 0.85;
  animation: microPulse 2.4s ease-in-out infinite;
}
#musicBtn.muted.is-playing::after,
#musicBtn.buffering.is-playing::after,
#musicBtn.silence.is-playing::after,
#musicBtn.music-disabled.is-playing::after { opacity: 0.25; animation-play-state: paused; }

@keyframes microPulse {
  0%,100% { transform: translateZ(0) scaleY(1); }
  50% { transform: translateZ(0) scaleY(1.2); }
}

/* Music popover styling - reuse design tokens */
.music-popover {
  position: fixed;
  background: var(--glass-color);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-lg);
  backdrop-filter: blur(var(--glass-blur));
  box-shadow: 0 6px 20px var(--shadow-color);
  padding: 0.75rem;
  z-index: 1000;
  min-width: 260px;
  transition: transform 120ms ease, opacity 120ms ease, height 120ms ease;
  transform-origin: bottom center;
  display: grid;
  grid-template-rows: auto auto auto 1fr; /* header, transport, slider row, visualizer grows */
  gap: 0.5rem;
}
.music-popover.sticky { pointer-events: auto; }
.music-popover.above { transform-origin: bottom center; }
.music-popover.below { transform-origin: top center; }
.music-popover.open { opacity: 1; transform: scale(1); }
.music-popover:not(.open) { opacity: 0; transform: scale(0.98); }

.music-transport {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  margin-bottom: 0.5rem;
}

.music-volume {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.music-label {
  font-size: 0.8rem;
  opacity: 0.8;
  color: var(--text-color);
  white-space: nowrap;
}

.music-slider-container {
  flex: 1;
  position: relative;
}

.music-slider {
  width: 100%;
  height: 6px;
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
  position: relative;
  cursor: pointer;
  border: 1px solid rgba(255,255,255,0.12);
}

.music-fill {
  height: 100%;
  width: 45%;
  background: linear-gradient(90deg, var(--accent-color), var(--glow-color));
  border-radius: 4px;
  box-shadow: 0 0 8px var(--glow-color);
}

.music-handle {
  position: absolute;
  top: 50%;
  transform: translate(-50%,-50%);
  width: 16px;
  height: 16px;
  background: var(--glass-color);
  border: 2px solid var(--accent-color);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--glow-color);
}

/* Music button subtle states */
#musicBtn.muted::after {
  content: '';
  position: absolute;
  width: 60%;
  height: 2px;
  background: var(--accent-color);
  left: 50%;
  top: 50%;
  transform: translate(-50%,-50%) rotate(45deg);
  border-radius: 2px;
  box-shadow: 0 0 8px var(--glow-color);
}
#musicBtn.hint {
  animation: glowPulse 2s ease-in-out 2;
}
#musicBtn.buffering {
  position: relative;
}
#musicBtn.buffering::before {
  content: '';
  position: absolute;
  width: 16px; height: 16px;
  border: 2px solid transparent;
  border-top-color: var(--accent-color);
  border-radius: 50%;
  right: 6px; top: 6px;
  animation: spin 1s linear infinite;
}
#musicBtn.silence { opacity: 0.9; }

@keyframes spin { to { transform: rotate(360deg); } }

/* Progress slider inside visualizer */
.music-progress {
  display: grid;
  grid-template-columns: 1fr auto;
  align-items: center;
  gap: 8px;
  margin: 6px 0 2px;
}

.music-timecodes {
  display: flex;
  gap: 10px;
  font-size: 0.72rem;
  opacity: 0.75;
  color: var(--text-color);
}

.music-progress-track {
  position: relative;
  height: 6px;
  background: rgba(255,255,255,0.08);
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 4px;
  cursor: pointer;
  overflow: hidden;
}

.music-progress-fill {
  position: absolute;
  height: 100%;
  left: 0;
  top: 0;
  width: 0%;
  background: linear-gradient(90deg, var(--accent-color), var(--glow-color));
  box-shadow: 0 0 8px var(--glow-color);
  border-radius: 4px 0 0 4px;
}

.music-progress-handle {
  position: absolute;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 12px;
  height: 12px;
  left: 0%;
  background: var(--glass-color);
  border: 2px solid var(--accent-color);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--glow-color);
  transition: transform 80ms ease;
}
.music-progress-track.active .music-progress-handle,
.music-progress-handle.active {
  transform: translate(-50%, -50%) scale(1.08);
}
</style>
</body>

</html>
